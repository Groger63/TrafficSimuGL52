/** 
 * Agent conducteur possédant un corps (Car)
 */
package ^agent

import environnement.AbstractStaticObject
import environnement.Car
import environnement.InfluenceAgent
import events.GPSPath
import events.GPSPathReturn
import events.NeedInfluence
import events.SendedInfluence
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import java.util.ArrayList
import org.arakhne.afc.gis.road.primitive.RoadSegment

/** 
 * @author Nicolas
 * 
 */
agent Conducteur {
	uses Logging
	uses Lifecycle
	uses DefaultContextInteractions
	
	var percepts : ArrayList<AbstractStaticObject>
	var influence : InfluenceAgent
	var seeking = new BehaviorSeeking()
	var following = new BehaviorFollowing()
	var body : Car
	var gpsPath : ArrayList<RoadSegment> = null
	
	var maxSpeed : float
	
	on Initialize {
		emit(new GPSPath())
	}

	on Destroy {
		killMe
	}
	
	on GPSPathReturn{
		this.gpsPath = new ArrayList(occurrence.gpsPath.toArray)
	}
	
	/* Reçu à la fin du traitement des perceptions par l'environnement */
	on NeedInfluence{
		this.percepts = occurrence.percepts
		this.body = occurrence.body
		computeInfluence()
	}
	
	def computeInfluence()
	{
		var acc : float
		var selectedPath = this.gpsPath
		/*var obj = NextObjectOnPath(percepts)
		computeMaxSpeed(percepts)
		if(this.gpsPath == null)
		{ 
			acc = 0
			emit(new GPSPath())
		}
		else if (obj != null){
			var distance = computeDistanceBefore(obj)
			acc = this.following.run(this.body, distance, this.maxSpeed)
		}
		else
		 */
		this.maxSpeed = 50
		acc = this.seeking.run(this.body, this.maxSpeed)
		emit(new SendedInfluence(new InfluenceAgent(selectedPath, acc)))
	}
	
	def computeDistanceBefore(object : AbstractStaticObject) : float {
		var distance : float
		return distance
	}
	def NextObjectOnPath(roads : ArrayList<RoadSegment>) : AbstractStaticObject 
	{
		
	}

	def computeMaxSpeed(segments : ArrayList<RoadSegment>) : float {
		return 0
	}
	
}