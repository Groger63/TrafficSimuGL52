/** 
 * Agent conducteur possédant un corps (Car)
 */
package ^agent

import environnement.AbstractStaticObject
import environnement.Car
import environnement.InfluenceAgent
import events.GPSPath
import events.GPSPathReturn
import events.NeedInfluence
import events.SendedInfluence
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import java.util.ArrayList
import org.arakhne.afc.gis.road.primitive.RoadSegment
import events.TargetReached

/** 
 * @author Nicolas
 * 
 */
agent Conducteur {
	uses Logging
	uses Lifecycle
	uses DefaultContextInteractions
	
	var percepts : ArrayList<AbstractStaticObject>
	var seeking = new BehaviorSeeking()
	var following = new BehaviorFollowing()
	var body : Car
	
	var maxSpeed : float
	
	on Initialize {
		emit(new GPSPath())
	}

	on Destroy {
		killMe
	}
	 
	
	/* Reçu à la fin du traitement des perceptions par l'environnement */
	on NeedInfluence{
		this.percepts = occurrence.percepts
		this.body = occurrence.body
		if(this.body.gps.size() == 0)
		{
			if (this.body.position == this.body.segment.length || this.body.position == 0)
			{
				if (this.body.entryPoint == this.body.segment.beginPoint &&
					this.body.position == this.body.segment.length)
					emit(new TargetReached())
				else if(this.body.entryPoint == this.body.segment.endPoint &&
					this.body.position == 0)
					emit(new TargetReached())
			}
		}
		computeInfluence() 
	}
	
	def computeInfluence()
	{
		var acc : float
		this.maxSpeed = 50 // A remplacer par véritable limite de vitesse
		acc = this.seeking.run(this.body, this.maxSpeed) 
		var selectedPath = this.body.gps 
		/*var obj = NextObjectOnPath(percepts)
		computeMaxSpeed(percepts)
		if(this.gpsPath == null)
		{ 
			acc = 0
			emit(new GPSPath())
		}
		else if (obj != null){
			var distance = computeDistanceBefore(obj)
			acc = this.following.run(this.body, distance, this.maxSpeed)
		}
		else
			acc = this.seeking.run(this.body, this.maxSpeed) 
		 */
		emit(new SendedInfluence(new InfluenceAgent(selectedPath, acc)))
	}
	 
	def computeDistanceBefore(object : AbstractStaticObject) : float {
		var distance : float
		return distance
	}
	def NextObjectOnPath(roads : ArrayList<RoadSegment>) : AbstractStaticObject 
	{
		
	}

	def computeMaxSpeed(segments : ArrayList<RoadSegment>) : float {
		return 0
	}
	
}