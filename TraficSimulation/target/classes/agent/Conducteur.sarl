/** 
 * Agent conducteur possédant un corps (Car)
 */
package ^agent

import environnement.AbstractStaticObject
import environnement.Car
import environnement.InfluenceAgent
import events.GPSPath
import events.GPSPathReturn
import events.NeedInfluence
import events.SendedInfluence
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import java.util.ArrayList
import org.arakhne.afc.gis.road.primitive.RoadSegment
import events.AreYouAtHome
import events.IamAtHome
import java.util.HashSet

/** 
 * @author Nicolas
 * 
 */
agent Conducteur {
	uses Logging
	uses Lifecycle
	uses DefaultContextInteractions
	
	var percepts : HashSet<AbstractStaticObject>
	var seeking = new BehaviorSeeking()
	var following = new BehaviorFollowing()
	var body : Car
	
	var maxSpeed : float
	
	on Initialize {
		emit(new GPSPath())
	}

	on Destroy {
		killMe
	}
	 
	
	/* Reçu à la fin du traitement des perceptions par l'environnement */
	on NeedInfluence{
		this.percepts = occurrence.percepts
		this.body = occurrence.body
		computeInfluence() 
	} 
	
	def computeInfluence()
	{
		var selectedPath = this.body.gps 
		var acc : float
		if(amIAtHome)
		{
			acc = 0
			emit(new IamAtHome(true))
		}
		else
		{
			this.maxSpeed = getMaxSpeed() // A remplacer par véritable limite de vitesse
			acc = this.seeking.run(this.body, this.maxSpeed)
		}
		emit(new SendedInfluence(new InfluenceAgent(selectedPath, acc)))
	}

	def amIAtHome : boolean {
		if (this.body.gps.size() == 0) {
			if (this.body.position >= this.body.segment.length - 5 || this.body.position <= 5) {
				if (this.body.entryPoint == this.body.segment.beginPoint &&
					this.body.position >= this.body.segment.length - 5) {
					return true
				} else if (this.body.entryPoint == this.body.segment.endPoint && this.body.position <= 5) {
					return true
				}
			}
		}
		return false
	}
	 
	 //TODO
	 def getMaxSpeed()
	{
		var percepts = this.percepts
		
		return 50
	}
	def computeDistanceBefore(object : AbstractStaticObject) : float {
		var distance : float
		return distance
	}
	def NextObjectOnPath(roads : ArrayList<RoadSegment>) : AbstractStaticObject 
	{
		
	}

	def computeMaxSpeed(segments : ArrayList<RoadSegment>) : float {
		return 0
	}
	
}