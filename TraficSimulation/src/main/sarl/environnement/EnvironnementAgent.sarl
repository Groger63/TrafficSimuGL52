/** 
 * Agent d'environnement à lancer pour démarrer la simulation
 */
package environnement

import ^agent.Conducteur
//import configurationWindow.ConfRenderer
import events.BeginLoop
import events.EndLoop
import events.NeedInfluence
import events.SendedInfluence
import events.TargetReached
import io.sarl.core.Behaviors
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Logging
import io.sarl.util.IdentifierScope
import java.util.ArrayList
import java.util.HashMap
import java.util.UUID
import org.arakhne.afc.gis.road.StandardRoadNetwork
import org.arakhne.afc.gis.road.layer.RoadNetworkLayer
import org.arakhne.afc.math.geometry.d1.d.Point1d
import traficWindow.RoadRenderer
import utils.Loader

import static traficWindow.RoadRenderer.*
import org.arakhne.afc.gis.road.primitive.RoadConnection
import org.arakhne.afc.gis.road.primitive.RoadSegment
import configurationWindow.CarModel
import events.GPSPath
import events.GPSPathReturn
import org.arakhne.afc.gis.road.path.RoadPath
import org.arakhne.afc.gis.road.path.astar.RoadAStar

/** 
 * @author Nicolas
 * 
 */
agent EnvironnementAgent {
	uses DefaultContextInteractions
	uses Logging
	uses Behaviors
	
	var roadNetwork : StandardRoadNetwork
	var agents : ArrayList<UUID> = new ArrayList<UUID>
	var agentBodies : HashMap<UUID, Car> = new HashMap<UUID, Car> 
	var influences : HashMap<UUID, InfluenceAgent> = new HashMap<UUID, InfluenceAgent>
	var impasses : ArrayList<RoadConnection> = new ArrayList<RoadConnection>
	var crois2 : ArrayList<RoadConnection> = new ArrayList<RoadConnection> //Croisement entre 3 routes
	var crois3 : ArrayList<RoadConnection> = new ArrayList<RoadConnection> //Croisement entre au moins 4 routes
	
	on Initialize {
		this.roadNetwork = Loader.loadShapeFile("ressources/ciechanow.shp")
		
		// loadPotentialPanelPositions()
		var segments = this.roadNetwork.getRoadSegments
		/*for (segment : segments)
		{
			System.out.println("Nom : " + segment.getName + ", longueur : " + segment.getLength + ", type : " +
				segment.getRoadType + ", num : " + segment.getRoadNumber)
			System.out.println(segment.getName)
		}*/
		RoadRenderer.roadLayer = new RoadNetworkLayer(this.roadNetwork);
		RoadRenderer.render()
		ConfRenderer.render()
		
		
		//wake(new BeginLoop)
	}
	
	on BeginLoop
	{
		this.influences = new HashMap<UUID, InfluenceAgent>()
		computePerceptions()
	}
	on EndLoop
	{
		for(conduc : this.agents)
		{
			if(this.agentBodies.containsKey(conduc)){
				consumeInfluence(agentBodies.get(conduc), influences.get(conduc))
			}
		}
		Thread.sleep(150)
		wake(new BeginLoop)
	}
	
	on SendedInfluence
	{
		this.influences.put(occurrence.source.UUID, occurrence.influence)
		if(this.influences.size() == this.agentBodies.size())
		{
			wake(new EndLoop)
		}
	}
	
	on TargetReached
	{
		var id = occurrence.source.UUID
		removeAgent(id)
	}
	
	on GPSPath
	{
		var roads : RoadPath = null
		if (this.agentBodies.get(occurrence.getSource.UUID) != null)
		{
			var entryPoint = this.agentBodies.get(occurrence.getSource.UUID).entryPoint
			var finalPoint : RoadConnection 
			do
			{
				finalPoint = this.impasses.get(Math.round(Math.random() * this.impasses.size()).intValue)
			}
			while (finalPoint == entryPoint)

			var aStar = new RoadAStar()
			roads = aStar.solve(entryPoint.getPoint, finalPoint, this.roadNetwork)
		}
		emit(new GPSPathReturn(roads))
	}
	
	def addAgent(model : CarModel)
	{
		var id = spawn(Conducteur)
		var numSpawner = Math.floor(Math.random() * this.impasses.size()).intValue
		var car = new Car(UUID.randomUUID, this.impasses.get(numSpawner) , model)
		this.agents.add(id)
		this.agentBodies.put(id, car)
	}
	def removeAgent(id : UUID)
	{
		this.agentBodies.remove(id)
		this.agents.remove(id)
		emit(new Destroy(), new IdentifierScope(id))
	}
	
	
	def computePerceptions()
	{
		for(id : this.agents)
		{
			if (this.agentBodies.containsKey(id)){
				var agentBody = this.agentBodies.get(id)
				var percepts = computePerceptionsFor(agentBody)
				emit(new NeedInfluence(percepts, agentBody), new IdentifierScope(id))
			}
		}
	}
	
	
	def computePerceptionsFor(body : Car) : ArrayList<RoadSegment>
	{
		return new ArrayList<RoadSegment>
	}

	def consumeInfluence(car : Car, ^agent : InfluenceAgent) {
		
	}

	def loadPotentialPanelPositions {
		var allSegments = this.roadNetwork.getRoadSegments
		
		for (segment : allSegments) {
			var firstPoint = segment.getBeginPoint
			if (!impasses.contains(firstPoint) && !crois2.contains(firstPoint) && !crois3.contains(firstPoint)) {
				if (firstPoint.isFinalConnectionPoint) {
					this.impasses.add(firstPoint)
				} else if (firstPoint.getConnectedSegmentCount == 3) {
					this.crois2.add(firstPoint)
				} else if (firstPoint.getConnectedSegmentCount > 3) {
					this.crois3.add(firstPoint)
				}
			}

			var lastPoint = segment.getEndPoint
			if (!impasses.contains(firstPoint) && !crois2.contains(firstPoint) && !crois3.contains(firstPoint)) {
				if (lastPoint.isFinalConnectionPoint) {
					this.impasses.add(lastPoint)
				} else if (lastPoint.getConnectedSegmentCount == 3) {
					this.crois2.add(lastPoint)
				} else if (lastPoint.getConnectedSegmentCount > 3) {
					this.crois3.add(lastPoint)
				}
			}
		}
	}
}