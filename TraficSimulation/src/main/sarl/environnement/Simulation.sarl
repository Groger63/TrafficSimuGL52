/** 
 * Agent d'environnement à lancer pour démarrer la simulation
 */
package environnement

import ^agent.Conducteur
import events.AreYouAtHome
import events.BeginLoop
import events.EndLoop
import events.IamAtHome
import events.NeedInfluence
import events.SendedInfluence
import io.sarl.core.Behaviors
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.util.IdentifierScope
import java.util.ArrayList
import java.util.HashMap
import java.util.UUID
import java.util.concurrent.ConcurrentHashMap
import javafx.scene.paint.Color
import org.arakhne.afc.gis.road.layer.RoadNetworkLayer
import org.arakhne.afc.gis.road.path.RoadPath
import org.arakhne.afc.gis.road.path.astar.RoadAStar
import org.arakhne.afc.gis.road.primitive.RoadConnection
import org.arakhne.afc.gis.road.primitive.RoadSegment
import traficWindow.CarLayer
import traficWindow.RoadRenderer
import utils.Loader
import utils.PersonalizedRoadNetwork
import utils.ThreadComputer

import static extension traficWindow.RoadRenderer.*

/** 
 * @author Nicolas
 * 
 */
@SuppressWarnings("potential_field_synchronization_problem")
agent Simulation{
	uses DefaultContextInteractions
	uses Behaviors
	
	var  roadNetwork : PersonalizedRoadNetwork
	var agents : ArrayList<UUID> = new ArrayList<UUID>
	var agentBodies : ConcurrentHashMap<UUID, Car> = new ConcurrentHashMap<UUID, Car> 
	var influences : HashMap<UUID, InfluenceAgent> = new HashMap<UUID, InfluenceAgent>
	var isCarAtHome : HashMap<UUID, Boolean> = new HashMap<UUID, Boolean>
	var desiredNbModel : HashMap<String, Integer> = new HashMap()
	var actualNbModel : HashMap<String, Integer> = new HashMap()
	var definedModels : HashMap<String, CarModel> = new HashMap() 
	var timespace : int = 1000
	var roadRenderer : RoadRenderer
	var lightRoadConnections = new ArrayList<LightRoadConnection>()
	
	on Initialize { 
		this.roadNetwork = Loader.loadShapeFile("ressources/Quartier.shp")
		RoadRenderer.roadLayer = new RoadNetworkLayer(this.roadNetwork);
		RoadRenderer.carLayer = new CarLayer(agentBodies.values());
		 
		  
		this.roadRenderer = ThreadComputer.startRoadRenderer()
		generateDefaultPanels()
		
		//ConfRenderer.render()

		//roadRenderer.test();
		var carModel1 = new CarModel(10, 20, 20, 20, new Color(0,0,0, 0), "TEST", 150)
		addModel(carModel1)
		addAgentToTheSimulation(carModel1, 0)
		addAgentToTheSimulation(carModel1, 2)
		addAgentToTheSimulation(carModel1, 5)
		wake(new BeginLoop)
		/*
		//Car elements
		var car_elements : InformedArrayList<Point2d> = new InformedArrayList();
		car_elements.add(new Point2d(0.0, 20.0));
		car_elements.add(new Point2d(400.0, -310.0));
		this.roadRenderer.setCars(car_elements);
		//Traffic light panel
		var light_panel_elements : InformedArrayList<Point2d> = new InformedArrayList();
		light_panel_elements.add(new Point2d(185.0, -275.0));
		light_panel_elements.add(new Point2d(325.0, -147.0));
		var light_panel_state : InformedArrayList<Boolean> = new InformedArrayList();
		light_panel_state.add(true); //green light
		light_panel_state.add(false); //red light
		//Stop and speed panels
		var road_panel_elements : InformedArrayList<Point2d> = new InformedArrayList();
		road_panel_elements.add(new Point2d(-45.0, -335.0));
		road_panel_elements.add(new Point2d(185.0, -132.0));
		var road_panel_type : InformedArrayList<String> = new InformedArrayList();
		road_panel_type.add("stop");
		road_panel_type.add("speed");
		
		this.roadRenderer.setPannels(road_panel_elements, road_panel_type, light_panel_elements, light_panel_state);
		*/
	} 
	
	on BeginLoop {
		this.influences = new HashMap<UUID, InfluenceAgent>()
		this.isCarAtHome = new HashMap<UUID, Boolean>()
		this.roadRenderer.carLayer.update()
		// lightPanelProcess()
		this.roadRenderer.update()
		//lightPanelProcess()
		computePerceptions()
	}
	on EndLoop {
		System.out.println("CONSUME INFLUENCE")
		consumeInfluence()
		System.out.println("BEGIN AREYOUATHOME")
		Thread.sleep(this.timespace)
		emit(new AreYouAtHome())
	}
	on SendedInfluence{
		this.influences.put(occurrence.source.UUID, occurrence.influence)
		if(this.influences.size() == this.agentBodies.size())
		{
			wake(new EndLoop)
		}
	}
	on IamAtHome {
		this.isCarAtHome.put(occurrence.source.UUID, occurrence.arrived)
		if (this.isCarAtHome.size() == this.agentBodies.size())
		{
			var conducsToKill : ArrayList<UUID> = new ArrayList<UUID>()

			System.out.println("CARATHOME : " + this.isCarAtHome)
			System.out.println("AGENTBODY : " + this.agentBodies)
			for (conduc : this.agents) {
				if (this.isCarAtHome.get(conduc)) {
					System.out.println("CONDUCTEUR : " + conduc)
					conducsToKill.add(conduc)
				}
			}
			for(conduc : conducsToKill)
			{
				removeAgentFromTheSimulation(conduc)
			}
			wake(new BeginLoop)
		}
	}
	
	def definesGPSPath(car : Car) : ArrayList<RoadSegment>{
		var roads : RoadPath = null
		var entryPoint = car.entryPoint
		var finalPoint : RoadConnection 
		do
		{
			var newTempID = Math.round(Math.random() * (this.roadNetwork.impasses.size() - 1)).intValue
			finalPoint = this.roadNetwork.impasses.get(newTempID)
		}
		while (finalPoint == entryPoint)

		var aStar = new RoadAStar()
		roads = aStar.solve(entryPoint.getPoint, finalPoint, this.roadNetwork)
		var newPathRoad : ArrayList<RoadSegment> = new ArrayList(roads.toArray())
		return newPathRoad
	}
	def redefinesGPSPath(car : Car) : ArrayList<RoadSegment>{
		if (car.gps.size() == 0)
			return car.gps
		var newPath = car.gps
		if (newPath.get(0) == car.segment) {
			newPath.remove(0) 
		}
		return newPath
	}
	def generateDefaultPanels()
	{
		this.roadNetwork.analizeNetwork
		for (point : this.roadNetwork.threeRoadConnections) {
			this.roadNetwork.addStopPanelOnThisRoadConnection(point)
		}
		for (point : this.roadNetwork.fourRoadConnections) {
			addLightPanelsOnThisRoadConnection(point)
		}
	}
	def addLightPanelsOnThisRoadConnection(point : RoadConnection){
		var lightPoint = new LightRoadConnection(point)
		var distance : float
		this.lightRoadConnections.add(lightPoint)
		for (segment : point.connectedSegments)
		{
			if(point == segment.getEndPoint)
			{
				distance = (segment.getDistanceToEnd(0) - 10).floatValue
			}
			else
			{
				distance = 10
			}
			lightPoint.addLightPanel(this.roadNetwork.addLightPanel(distance, segment, point, false))
		}
	}
	def lightPanelProcess(){
		for (lightPoint : this.lightRoadConnections)
		{
			lightPoint.incrTimeCycle()
		}
	}
	def chooseModelForNewAgent() : CarModel{
		var newModel : CarModel
		for (modelName : desiredNbModel.keySet)
		{
			var nbDesired = desiredNbModel.get(modelName)
			var nbActual = actualNbModel.get(modelName)
			
			if(nbDesired > nbActual)
				return newModel
		}
		return null
	}
	def addModel(model : CarModel){
		this.definedModels.put(model.name, model)
	}
	def removeModel(name : String){
		this.definedModels.remove(name)
	}
	def addAgentToTheSimulation(model : CarModel, idSpawneur : int){
		var id = spawn(Conducteur)
		var point = this.roadNetwork.impasses.get(idSpawneur)
		var segment = point.getConnectedSegment(0)
		var car = new Car(UUID.randomUUID, point, model)
		car.gps = definesGPSPath(car)
		this.agents.add(id)
		this.agentBodies.put(id, car)
		if (this.actualNbModel.containsKey(model.name))
			this.actualNbModel.put(model.name, this.actualNbModel.get(model.name) + 1)
		else
			this.actualNbModel.put(model.name, 1)

		this.roadNetwork.addObjectToThisSegment("CAR", car, segment)
	}
	def removeAgentFromTheSimulation(id : UUID){
		var car = this.agentBodies.get(id)
		this.roadNetwork.removeObjectFromHisSegment("CAR", car) 
		
		this.agentBodies.remove(id)
		this.agents.remove(id)
		emit(new Destroy(), new IdentifierScope(id)) 

		this.agentBodies.remove(id)
		var model = car.model
		if (this.actualNbModel.containsKey(model.name))
			this.actualNbModel.put(model.name, this.actualNbModel.get(model.name) + 1)
		else
			this.actualNbModel.put(model.name, 1)
	}
	def computePerceptions(){
		for(id : this.agents)
		{
			if (this.agentBodies.containsKey(id)){
				var agentBody = this.agentBodies.get(id)
				var percepts = computePerceptionsFor(agentBody)
				emit(new NeedInfluence(percepts, agentBody), new IdentifierScope(id))
			}
		}
	}
	def computePerceptionsFor(body : Car) : ArrayList<AbstractStaticObject> {
		var position = body.position
		var viewDistance = body.model.viewDistance
		return exploreSegments(body.entryPoint, body.segment, viewDistance, position, body)
	}
	def exploreSegments(entryPoint : RoadConnection, segment : RoadSegment, distance : float, position : float, body : AbstractStaticObject) : ArrayList<AbstractStaticObject>{

		var restDisView : float
		var newPos : float = position
		var percepts = new ArrayList<AbstractStaticObject>
		if (entryPoint == segment.beginPoint) {
			if (newPos == -1)
				newPos = 0
			restDisView = distance - segment.getDistanceToEnd(newPos).floatValue

		} else {
			if (newPos == -1)
				newPos = segment.getDistanceToEnd(0).floatValue
			restDisView = distance - segment.getDistanceFromStart(newPos).floatValue

		}

		var tempsPercepts = new ArrayList<AbstractStaticObject>
		var unClassedPercepts = new ArrayList<AbstractStaticObject>
		if (segment.hasUserData("PANEL"))
			unClassedPercepts.addAll(segment.getUserDataCollection("PANEL"))
		if (segment.hasUserData("CAR"))
			unClassedPercepts.addAll(segment.getUserDataCollection("CAR"))
		
		for (percept : unClassedPercepts)
		{
			if (percept.entryPoint == entryPoint && percept != body)
				tempsPercepts.add(percept)
		}
		if (restDisView < 0)
		{
			if(entryPoint == segment.beginPoint)
			{
				for (obj : tempsPercepts) {
					if (segment.getDistanceFromStart(obj.position) <= distance  &&
						!tempsPercepts.contains(obj))
						tempsPercepts.add(obj)
				}
			}
			else
			{
				for (obj : tempsPercepts) {
					if (segment.getDistanceToEnd(obj.position) <= distance  && !tempsPercepts.contains(obj))
						tempsPercepts.add(obj)
				}
			}
			return percepts
		}
		else
		{
			var nextPoint : RoadConnection
			
			if (entryPoint == segment.beginPoint)
				nextPoint = segment.endPoint
			else
				nextPoint = segment.beginPoint
				
			percepts.addAll(tempsPercepts)
			for (newSegment : nextPoint.connectedSegments) {
				if(newSegment !=  body.segment)
				{
					percepts.addAll(exploreSegments(nextPoint, newSegment, restDisView, -1, body))
				}
			}
			return percepts
		}
	}
	def consumeInfluence()
	{
		for (conduc : this.agents) {
			if (this.agentBodies.containsKey(conduc)) {
				consumeInfluenceFor(agentBodies.get(conduc), influences.get(conduc)) 
			}
		}
	}
	def consumeInfluenceFor(car : Car,  influence : InfluenceAgent) {
		var roads = influence.roads
		var acceleration = influence.acceleration
		car.speed = car.speed + acceleration
		var distance = (car.speed * (this.timespace/1000.0)).floatValue
		move(car, distance, roads)
	}
	def move(car : Car, distance : float, roads : ArrayList<RoadSegment>){
		System.out.println("I MOVE : " + car)
		var segment = car.segment
		var segmentBeginPoint = segment.beginPoint 
		var entryPoint = car.entryPoint
		var distanceRest : float
		var endPoint : RoadConnection
		var newPosition : float
		if (entryPoint == segmentBeginPoint)
		{
			distanceRest = (segment.length - car.position).floatValue
			endPoint = segment.endPoint
			newPosition = car.position + distance
		}
		else
		{
			distanceRest = car.position
			endPoint = segment.beginPoint
			newPosition = car.position - distance
		}

		if(0 > (distanceRest - distance))
		{
			if(roads.size() == 0)
			{
				if(endPoint == car.segment.endPoint)
					newPosition = car.segment.length.floatValue
				else
					newPosition = 0
				car.position = newPosition
			}
			else
			{
				var nextRoad = roads.get(0)
	
				roads.remove(0)
				car.entryPoint = endPoint 
				car.segment = nextRoad
				if (nextRoad.beginPoint == endPoint)
				{
					car.position = 0
				}
				else
				{
					car.position = nextRoad.length.floatValue
				}
				distanceRest = (distanceRest - distance) * -1
	
				move(car, distanceRest, roads)
			}
		}
		else
		{
			car.position = newPosition
			this.roadNetwork.moveCarToSegment(car, car.segment)
			car.gps = redefinesGPSPath(car)
		}
		System.out.println("END OF MOVE FOR : " + car)  
	}
}