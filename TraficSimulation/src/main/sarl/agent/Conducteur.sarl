/** 
 * Agent conducteur possédant un corps (Car)
 */
package ^agent

import environnement.AbstractStaticObject
import environnement.Car
import environnement.InfluenceAgent
import events.GPSPath
import events.GPSPathReturn
import events.NeedInfluence
import events.SendedInfluence
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import java.util.ArrayList
import org.arakhne.afc.gis.road.primitive.RoadSegment
import events.AreYouAtHome
import events.IamAtHome
import java.util.HashSet
import environnement.Percept
import utils.Converter
import org.arakhne.afc.gis.road.primitive.RoadConnection

/** 
 * @author Nicolas
 * 
 */
agent Conducteur {
	uses Logging
	uses Lifecycle
	uses DefaultContextInteractions
	
	var percepts : HashSet<Percept>
	var seeking = new BehaviorSeeking()
	var arriving = new BehaviorArriving()
	var following = new BehaviorFollowing()
	var body : Car
	
	var maxSpeed : float = Converter.convertKHtoMS(50)
	
	on Initialize {
		emit(new GPSPath())
	}

	on Destroy {
		killMe
	}
	 
	
	/* Reçu à la fin du traitement des perceptions par l'environnement */
	on NeedInfluence{
		this.percepts = occurrence.percepts
		this.body = occurrence.body
		if (this.maxSpeed == 0) 
			this.maxSpeed = this.body.maxSpeed
		
		computeInfluence() 
	} 
	
	def computeInfluence()
	{
		var selectedPath = this.body.gps 
		var acc : float
		if(amIAtHome) 
		{
			acc = 0
			emit(new IamAtHome(true))
		}
		else
		{

			var maxSpeedTemp : Percept = null 
			var obstacleTemp : Percept = null
			var safetyDistance = (Converter.convertMStoKM(body.speed) / 10) * 6
			if (safetyDistance < 10)
				safetyDistance = 10
			
			//On cherche l'obstacle le plus proche
			for (percept : percepts) {
				// On ne retient que les Percept sur notre chemin
				if (selectedPath.contains(percept.segment) || (percept.segment == body.segment))
				{
					if (percept.distance < 50 && percept.type == "SPEED") {
						if (maxSpeedTemp == null || maxSpeedTemp.distance > percept.distance)
							maxSpeedTemp = percept
					}
					else if (percept.type == "CAR") {
						if (obstacleTemp == null || obstacleTemp.distance > percept.distance)
						{
							obstacleTemp = percept
						}
					}
					else if ((percept.type == "LIGHT" && (percept.data == false)) || percept.type == "STOP")
					{
						if (obstacleTemp == null || obstacleTemp.distance > percept.distance)
						{
							obstacleTemp = percept
						}
					}
				}
			} 

			// Dans le cas où un obstacle se situe devant le véhicule
			if (maxSpeedTemp != null && maxSpeedTemp.speed < this.body.maxSpeed)
			{
				this.maxSpeed = maxSpeedTemp.speed
			}
				
			
			
			if (obstacleTemp != null)
			{
				if (obstacleTemp.speed == 0)
				{
					//Dans le cas où le panneau STOP a été respecté, ne plus en tenir compte
					if (obstacleTemp.type == "STOP" && (this.body.speed < 0.5 || obstacleTemp.distance < 10) &&
						checkFreeRoad()) {
						this.percepts.remove(obstacleTemp)
						computeInfluence()
						return
					}
					//Sinon, ralentir à son approche
					acc = this.arriving.run(this.body, obstacleTemp.distance, this.maxSpeed)
					
				}
				//Sinon (en général dans le cas des voitures)
				else
				{
					acc = this.following.run(this.body, obstacleTemp.distance, this.maxSpeed, obstacleTemp.speed)
				}
				
			}
			//Dans le cas où il n'y a aucun obstacle
			else
			{
				acc = this.seeking.run(this.body, this.maxSpeed)				
			}
		}
		
		emit(new SendedInfluence(new InfluenceAgent(selectedPath, acc)))
	}

	def checkFreeRoad : boolean {
		var checkConfirm = true
		var endPoint : RoadConnection
		if(this.body.entryPoint == this.body.segment.beginPoint)
			endPoint = this.body.segment.endPoint
		else 
			endPoint = this.body.segment.beginPoint
			
		for(percept : this.percepts)
		{
			if (percept.speed < this.body.speed && percept.segment != this.body.segment && percept.distance < 30 && percept.entryPoint != endPoint && percept.type == "CAR")
			{ 
				checkConfirm = false
			}
		}
		
		return checkConfirm
	}

	def amIAtHome : boolean {
		if (this.body.gps.size() == 0) {
			if (this.body.position >= this.body.segment.length - 5 || this.body.position <= 5) {
				if (this.body.entryPoint == this.body.segment.beginPoint &&
					this.body.position >= this.body.segment.length - 5) {
					return true 
				} else if (this.body.entryPoint == this.body.segment.endPoint && this.body.position <= 5) {
					return true
				}
			}
		}
		return false
	}
	 
	def computeDistanceBefore(object : AbstractStaticObject) : float {
		var distance : float
		return distance
	}
	def NextObjectOnPath(roads : ArrayList<RoadSegment>) : AbstractStaticObject 
	{
		
	}
	
}